import esbuild from "esbuild";
import builtins from "builtin-modules";
import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
`;

const prod = process.argv[2] === "production";

function loadEnvFile(filePath) {
	if (!fs.existsSync(filePath)) {
		return;
	}

	const contents = fs.readFileSync(filePath, "utf8");
	for (const line of contents.split(/\r?\n/)) {
		const trimmed = line.trim();
		if (!trimmed || trimmed.startsWith("#")) {
			continue;
		}

		const [key, ...rest] = trimmed.split("=");
		if (!key) {
			continue;
		}

		const value = rest.join("=");
		if (!(key in process.env)) {
			process.env[key] = value;
		}
	}
}

// Minimal tsconfig-paths resolver plugin (no external deps)
function tsconfigPathsPlugin({ tsconfigPath }) {
	const name = "tsconfig-paths";
	let mappings = [];
	let baseUrl = "";
	const tsconfigDir = path.dirname(tsconfigPath);
	return {
		name,
		setup(build) {
			try {
				const raw = fs.readFileSync(tsconfigPath, "utf8");
				const json = JSON.parse(raw);
				const paths = (json.compilerOptions && json.compilerOptions.paths) || {};
				baseUrl = (json.compilerOptions && json.compilerOptions.baseUrl) || "";
				for (const [alias, targets] of Object.entries(paths)) {
					// Only first target is used for bundling
					const pattern = String(alias).replace(/\*/g, "(.+)");
					const regex = new RegExp(`^${pattern}$`);
					const target = String((targets && targets[0]) || "");
					const replacement = target.replace(/\*/g, "$1");
					mappings.push({ regex, replacement });
				}
			} catch {
				// no-op; build will continue without aliasing
			}
			build.onResolve({ filter: /.*/ }, (args) => {
				for (const { regex, replacement } of mappings) {
					if (regex.test(args.path)) {
						const substituted = args.path.replace(regex, replacement);
						const base = baseUrl ? path.resolve(tsconfigDir, baseUrl) : tsconfigDir;
						const withoutExt = path.resolve(base, substituted);

						// Try to resolve to an existing file by testing common extensions and index files
						const tryCandidates = (p) => {
							const exts = [".ts", ".tsx", ".js", ".jsx", ".mjs", ".cjs"];
							const candidates = [
								p,
								...exts.map((e) => p + e),
								...exts.map((e) => path.join(p, "index" + e)),
							];
							for (const candidate of candidates) {
								try {
									if (
										fs.existsSync(candidate) &&
										fs.statSync(candidate).isFile()
									) {
										return candidate;
									}
								} catch {
									// ignore
								}
							}
							return null;
						};

						const resolved = tryCandidates(withoutExt);
						if (resolved) {
							return { path: resolved };
						}

						// Fall back to returning the path without extension; this mirrors previous behavior
						// but now only happens when no candidate file exists.
						return { path: withoutExt };
					}
				}
				return null;
			});
		},
	};
}

const ___filename = fileURLToPath(import.meta.url);
const ___dirname = path.dirname(___filename);
const rootDir = path.resolve(___dirname, ".");

const envFiles = [
	path.resolve(rootDir, ".env"),
	path.resolve(rootDir, prod ? ".env.production" : ".env.development"),
];

for (const candidate of envFiles) {
	loadEnvFile(candidate);
}

const defaultServerUrl = prod
	? "https://keepsidianserver-i55qr5tvea-uc.a.run.app"
	: "http://localhost:8080";

const resolvedServerUrl = String(process.env.KEEPSIDIAN_SERVER_URL ?? defaultServerUrl).replace(
	/\/$/,
	""
);

const context = await esbuild.context({
	banner: {
		js: banner,
	},
	entryPoints: ["src/main.ts"],
	bundle: true,
	external: [
		"obsidian",
		"electron",
		"@codemirror/autocomplete",
		"@codemirror/collab",
		"@codemirror/commands",
		"@codemirror/language",
		"@codemirror/lint",
		"@codemirror/search",
		"@codemirror/state",
		"@codemirror/view",
		"@lezer/common",
		"@lezer/highlight",
		"@lezer/lr",
		...builtins,
	],
	format: "cjs",
	target: "es2018",
	logLevel: "info",
	sourcemap: prod ? false : "inline",
	treeShaking: true,
	outfile: "main.js",
	plugins: [tsconfigPathsPlugin({ tsconfigPath: path.resolve(rootDir, "tsconfig.json") })],
	define: {
		"process.env.KEEPSIDIAN_SERVER_URL": JSON.stringify(resolvedServerUrl),
	},
});

if (prod) {
	await context.rebuild();
	process.exit(0);
} else {
	await context.watch();
}
